/**
 * Created by feichongzheng on 16/12/30.
 */
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    var cookie = require('cookie');

    if (typeof Object.assign != 'function') {
        Object.assign = function(target) {
            'use strict';
            if (target == null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }

            target = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (source != null) {
                    for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }
            }
            return target;
        };
    }

    var _rawCookie = {};
    var _res = undefined;

    function _isResWritable() {
        if(!_res)
            return false
        if(_res.headersSent === true)
            return false
        return true
    }

    function load(name, doNotParse) {
        var cookies = (typeof document === 'undefined') ? _rawCookie : cookie.parse(document.cookie);
        var cookieVal = cookies && cookies[name];

        if (typeof doNotParse === 'undefined') {
            doNotParse = !cookieVal || (cookieVal[0] !== '{' && cookieVal[0] !== '[');
        }

        if (!doNotParse) {
            try {
                cookieVal = JSON.parse(cookieVal);
            } catch(e) {
                // Not serialized object
            }
        }

        return cookieVal;
    }

    function select(regex) {
        var cookies = (typeof document === 'undefined') ? _rawCookie : cookie.parse(document.cookie);
        if(!cookies)
            return {}
        if(!regex)
            return cookies
        return Object.keys(cookies)
            .reduce(function(accumulator, name) {
                if(!regex.test(name))
                    return accumulator
                var newCookie = {}
                newCookie[name] = cookies[name]
                return Object.assign({}, accumulator, newCookie)
            }, {})
    }

    function save(name, val, opt) {
        _rawCookie[name] = val;

        // allow you to work with cookies as objects.
        if (typeof val === 'object') {
            _rawCookie[name] = JSON.stringify(val);
        }

        // Cookies only work in the browser
        if (typeof document !== 'undefined') {
            document.cookie = cookie.serialize(name, _rawCookie[name], opt);
        }

        if (_isResWritable() && _res.cookie) {
            _res.cookie(name, val, opt);
        }
    }

    function remove(name, opt) {
        delete _rawCookie[name];

        if (typeof opt === 'undefined') {
            opt = {};
        } else if (typeof opt === 'string') {
            // Will be deprecated in future versions
            opt = { path: opt };
        } else {
            // Prevent mutation of opt below
            opt = Object.assign({}, opt);
        }

        if (typeof document !== 'undefined') {
            opt.expires = new Date(1970, 1, 1, 0, 0, 1);
            document.cookie = cookie.serialize(name, '', opt);
        }

        if (_isResWritable() && _res.clearCookie) {
            _res.clearCookie(name, opt);
        }
    }

    function setRawCookie(rawCookie) {
        if (rawCookie) {
            _rawCookie = cookie.parse(rawCookie);
        } else {
            _rawCookie = {};
        }
    }

    function plugToRequest(req, res) {
        if (req.cookie) {
            _rawCookie = req.cookie;
        } else if (req.cookies) {
            _rawCookie = req.cookies;
        } else if (req.headers && req.headers.cookie) {
            setRawCookie(req.headers.cookie);
        } else {
            _rawCookie = {};
        }

        _res = res;
        return function unplug() {
            _res = null;
            _rawCookie = {};
        }
    }

    var reactCookie = {
        load: load,
        select: select,
        save: save,
        remove: remove,
        setRawCookie: setRawCookie,
        plugToRequest: plugToRequest
    };

    if (typeof window !== 'undefined') {
        window['reactCookie'] = reactCookie;
    }

    module.exports = reactCookie;

},{"cookie":2}],2:[function(require,module,exports){
    /*!
     * cookie
     * Copyright(c) 2012-2014 Roman Shtylman
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */

    'use strict';

    /**
     * Module exports.
     * @public
     */

    exports.parse = parse;
    exports.serialize = serialize;

    /**
     * Module variables.
     * @private
     */

    var decode = decodeURIComponent;
    var encode = encodeURIComponent;
    var pairSplitRegExp = /; */;

    /**
     * RegExp to match field-content in RFC 7230 sec 3.2
     *
     * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
     * field-vchar   = VCHAR / obs-text
     * obs-text      = %x80-FF
     */

    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

    /**
     * Parse a cookie header.
     *
     * Parse the given cookie header string into an object
     * The object has the various cookies as keys(names) => values
     *
     * @param {string} str
     * @param {object} [options]
     * @return {object}
     * @public
     */

    function parse(str, options) {
        if (typeof str !== 'string') {
            throw new TypeError('argument str must be a string');
        }

        var obj = {}
        var opt = options || {};
        var pairs = str.split(pairSplitRegExp);
        var dec = opt.decode || decode;

        for (var i = 0; i < pairs.length; i++) {
            var pair = pairs[i];
            var eq_idx = pair.indexOf('=');

            // skip things that don't look like key=value
            if (eq_idx < 0) {
                continue;
            }

            var key = pair.substr(0, eq_idx).trim()
            var val = pair.substr(++eq_idx, pair.length).trim();

            // quoted values
            if ('"' == val[0]) {
                val = val.slice(1, -1);
            }

            // only assign once
            if (undefined == obj[key]) {
                obj[key] = tryDecode(val, dec);
            }
        }

        return obj;
    }

    /**
     * Serialize data into a cookie header.
     *
     * Serialize the a name value pair into a cookie string suitable for
     * http headers. An optional options object specified cookie parameters.
     *
     * serialize('foo', 'bar', { httpOnly: true })
     *   => "foo=bar; httpOnly"
     *
     * @param {string} name
     * @param {string} val
     * @param {object} [options]
     * @return {string}
     * @public
     */

    function serialize(name, val, options) {
        var opt = options || {};
        var enc = opt.encode || encode;

        if (typeof enc !== 'function') {
            throw new TypeError('option encode is invalid');
        }

        if (!fieldContentRegExp.test(name)) {
            throw new TypeError('argument name is invalid');
        }

        var value = enc(val);

        if (value && !fieldContentRegExp.test(value)) {
            throw new TypeError('argument val is invalid');
        }

        var str = name + '=' + value;

        if (null != opt.maxAge) {
            var maxAge = opt.maxAge - 0;
            if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
            str += '; Max-Age=' + Math.floor(maxAge);
        }

        if (opt.domain) {
            if (!fieldContentRegExp.test(opt.domain)) {
                throw new TypeError('option domain is invalid');
            }

            str += '; Domain=' + opt.domain;
        }

        if (opt.path) {
            if (!fieldContentRegExp.test(opt.path)) {
                throw new TypeError('option path is invalid');
            }

            str += '; Path=' + opt.path;
        }

        if (opt.expires) {
            if (typeof opt.expires.toUTCString !== 'function') {
                throw new TypeError('option expires is invalid');
            }

            str += '; Expires=' + opt.expires.toUTCString();
        }

        if (opt.httpOnly) {
            str += '; HttpOnly';
        }

        if (opt.secure) {
            str += '; Secure';
        }

        if (opt.sameSite) {
            var sameSite = typeof opt.sameSite === 'string'
                ? opt.sameSite.toLowerCase() : opt.sameSite;

            switch (sameSite) {
                case true:
                    str += '; SameSite=Strict';
                    break;
                case 'lax':
                    str += '; SameSite=Lax';
                    break;
                case 'strict':
                    str += '; SameSite=Strict';
                    break;
                default:
                    throw new TypeError('option sameSite is invalid');
            }
        }

        return str;
    }

    /**
     * Try decoding a string using a decoding function.
     *
     * @param {string} str
     * @param {function} decode
     * @private
     */

    function tryDecode(str, decode) {
        try {
            return decode(str);
        } catch (e) {
            return str;
        }
    }

},{}]},{},[1]);
